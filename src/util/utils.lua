---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Shuangjun Liu.
--- DateTime: 4/23/2018 9:20 PM
--- History: 19.3.22,  add sqrtPadding and crop PadIm
require 'image'
require 'math'
cv = require 'cv'
require 'cv.imgproc'

local M = {}    -- package
local function TableConcat(t1,t2)
    for i=1,#t2 do
        t1[#t1+1] = t2[i]
    end
    return t1
end

local function GenVecFromTo(x1,x2)
    -- return a vector tensor from x1 to x2
    local j = x1-1
    local ts = torch.Tensor(x2-x1+1)
    ts:apply(function() j=j+1
        return j
    end)
    return ts
end

local function BoundNum(x, min, max)
    return math.min(math.max(x,min),max)
end

local function DrawLabel(Im, jts_cur, ifTxt)
    local ifDbg = 1
    ifTxt = ifTxt or false
    local I_dr=Im
    local margin = 3
    local marginTxt = 10
    --local c,h,w =

    print('jts_cur size is', jts_cur:size())
    print('im size is', Im:size())
    for i = 1, jts_cur:size(1) do
        local dr_x_ul = BoundNum(jts_cur[i][1] -margin,0,Im:size(3))
        local dr_y_ul = BoundNum(jts_cur[i][2] - margin ,0,Im:size(2))
        local dr_x_br = BoundNum(jts_cur[i][1] + margin,0,Im:size(3))
        local dr_y_br = BoundNum(jts_cur[i][2] + margin ,0,Im:size(2))
        local dr_x_txt = BoundNum(jts_cur[i][1] ,marginTxt,Im:size(3)-marginTxt)
        local dr_y_txt = BoundNum(jts_cur[i][2]  ,marginTxt,Im:size(2)-marginTxt)
         I_dr = image.drawRect(I_dr, dr_x_ul,dr_y_ul, dr_x_br, dr_y_br)
        if ifTxt then
            --print(string.format('draw text %s at location (%d, %d)',tostring(i),jts_cur[i][1],jts_cur[i][2]))
            I_dr = image.drawText(I_dr,tostring(i),dr_x_txt,dr_y_txt,{color={0,255,0}, size=1})

            --I_dr=image.drawText(I_dr, "hello\nworld", 100, 100)
        end
    end
    image.display(I_dr)
end

function M.AddNoise(augNoise)
  return function(input)
     -- AWGN:
     -- torch.randn makes noise with mean 0 and variance 1 (=stddev 1)
     --  so we multiply the tensor with our augNoise factor, that has a linear relation with
     --  the standard deviation (but the variance will be increased quadratically).
     return torch.add(input, torch.randn(input:size()):float()*augNoise)
  end
end

local function ts2cvImg(img)
    local img_cv
    if img:size(1) == 3 then -- if rgb
        img_cv = img:index(1, torch.LongTensor{3,2,1}):clone()
    end
    img_cv = img_cv:permute(2,3,1)  -- channel back
    img_cv = img_cv*255
    img_cv = img_cv:byte()
    return img_cv
end

-- opencv TO TS img
local function cv2tsImg(img)
    local imgTs = img:permute(3, 1, 2):float():clone()/255; -- 312 to c ,h , w from 240 320 3 -- h,w,c tim -> ts
    if imgTs:size(1) ==3 then -- if rgb
        imgTs = imgTs:index(1, torch.LongTensor{3, 2, 1}) -- r,g,b channel
    end
    return imgTs
end

local function cannyTs(img)
    local imgCv =  ts2cvImg(img)
    local imgCanny = cv.Canny{image=imgCv, threshold1=opt.cannyTh1, threshold2 = 30}
    local imTs = cv2tsImg((imgCanny))
    return imTs
end

local function lapTs(img)
    -- apply laplacian edge detection on the image
    local imgCv = ts2cvImg(img)
    local imgLap = cv.Laplacian{imgCv,ddepth = cv.CV_16S}
    local imTs = cv2tsImg(imgLap)
    return imTs
end

local function LSP2MPI(joints_gt_lsp, marginScale, n_joints)
    n_joints = n_joints or 16       -- default 16
    marginScale = marginScale or 1.2
    -- from the joints_gt_lsp format, make mpii joints_gt,
    -- also return visibles, centers, scales, and lenTorsos ( length of torso)
    -- n_joints default 16 for MPI format
    local joints_gt_tmp = joints_gt_lsp:permute(3,2,1)  -- 3 x 14 x N
    local visiblesTmp = 1  - joints_gt_tmp:select(3,3)  -- 3rd dim the 3rd slice
    joints_gt_tmp = joints_gt_tmp:narrow(3,1,2)     -- 3rd dim  first 2
    local lenTorsosTmp = (joints_gt_tmp[{ {}, 3, {}}] - joints_gt_tmp[{ {}, 10, {}}]):norm(2, 2) -- right hip minus the left up shoulder  Nx1 norm of torso
        -- initalize joint_MPi_tmp
    local joints_MPI_tmp = torch.zeros(joints_gt_tmp:size(1), n_joints,2)
    local visiblesMPI = torch.ones(visiblesTmp:size(1), n_joints) -- N x16
    --joints_gt_tmp:add(1)      -- add or not not important here
    joints_MPI_tmp[{{},{1,6},{}}]:copy(joints_gt_tmp[{{},{1,6},{}}])
    joints_MPI_tmp[{{},{11,16},{}}]:copy(joints_gt_tmp[{{},{7,12},{}}])
    joints_MPI_tmp[{{},{7},{}}]:copy(joints_gt_tmp[{{},{3,4},{}}]:mean(2))
    joints_MPI_tmp[{{},{8},{}}]:copy(joints_gt_tmp[{{},13,{}}])
    joints_MPI_tmp[{{},{9},{}}]:copy(joints_gt_tmp[{{},13,{}}] +(joints_gt_tmp[{{},14,{}}] - joints_gt_tmp[{{},13,{}}])/3)
    joints_MPI_tmp[{{},{10},{}}]:copy(joints_gt_tmp[{{},14,{}}])

    visiblesMPI[{ {}, { 1, 6}}]:copy(visiblesTmp[{ {}, { 1, 6}}])
    visiblesMPI[{ {}, { 11, 16}}]:copy(visiblesTmp[{ {}, { 7, 12}}])
    visiblesMPI[{ {}, 8}]:copy(visiblesTmp[{ {}, 13}])
    visiblesMPI[{ {}, 10}]:copy(visiblesTmp[{ {}, 14}])

    local cTmp = torch.Tensor(joints_gt_tmp:size(1),2)
    local sTmp = torch.Tensor(joints_gt_tmp:size(1))
    for j = 1, joints_gt_tmp:size(1) do
        local joints_cur = joints_gt_tmp[j]   -- 16 x 2
        cTmp[j] = (joints_cur:max(1) + joints_cur:min(1))/2 -- average value of mean and max
        local ht = (joints_cur:max(1) - joints_cur:min(1)):max()
        sTmp[j] = ht/200 * marginScale     -- increase joint based scale
    end
    --print('things working')
    return joints_MPI_tmp, visiblesMPI, cTmp, sTmp, lenTorsosTmp
end

local function inTable(item, tbl)
    for key, value in pairs(tbl) do
        if value == item then return key end
    end
    return false
end

local function sqrPadding(img,stdL)
    -- padded the image to stdL square image with 128 gray value
    -- history: 1 return the st and end index and also the padding form
    -- pad direction, 0 for no padding,  1 for vertical , 2 for horizontal padding, -1 for malfunction case
    local ind_st, ind_end
    local imgPadded = torch.Tensor(img:size(1), stdL, stdL):fill(0.5)
    local scaleTo
    local padDrct = -1
    --local szDiff = img:size(2)- img:size(3) -- h - w
    -- greater edge
    -- scale to
    -- fill the imgPadded
    local imgSc = image.scale(img, stdL)
    if img:size(2) > img:size(3) then
        padDrct = 2
        scaleTo = stdL/ img:size(2)
        ind_st = math.ceil((img:size(2) - img:size(3))/2 * scaleTo)
        --imgPadded:narrow(3, ind_st, imgScl:size(3)):set(imgScl)
        imgPadded[{{},{},{ind_st, ind_st+imgSc:size(3)-1}}] = imgSc
        ind_end = ind_st+ imgSc:size(3)-1
    elseif img:size(2) < img:size(3) then
        padDrct = 1
        scaleTo = stdL/ img:size(3)
        ind_st = math.ceil((img:size(3) - img:size(2))/2 * scaleTo)
        --imgPadded:narrow(2, ind_st, imgSc:size(2)):set(imgSc) -- narrow can't work
        imgPadded[{{}, {ind_st, ind_st+imgSc:size(2)-1}, {}}] = imgSc
        ind_end = ind_st + imgSc:size(2)-1
    else
        padDrct = 0
        imgPadded = imgSc
    end
    return imgPadded, ind_st, ind_end, padDrct     -- return scaled cut
end

local function cropPadIm(img, ind_st, ind_end, padDrct)
    -- this is specially designed for cropping padded image to get rid of the gray margin
    -- based on the padDrct, crop the image from ind_st to ind_end,
    -- padDrct 1, for vertical, 2 for horizontal, 0 for no padding return original image
    local imgCropped
    if padDrct == 1 then
        --print('img size is', img:size())
        imgCropped = img[{{}, {ind_st, ind_end},{}}]
    elseif padDrct == 2 then
        imgCropped = img[{{}, {}, {ind_st, ind_end}}]
    elseif padDrct ==0 then
        imgCropped = img    -- original
    else
        error('the padDrct code is wrong')
    end
    --print('result cropped img has size', imgCropped:size())
    return  imgCropped
end

M.TableConcat = TableConcat
M.GenVecFromTo = GenVecFromTo
M.DrawLabel = DrawLabel
M.ts2cvImg  = ts2cvImg
M.cv2tsImg = cv2tsImg
M.cannyTs = cannyTs
M.lapTs = lapTs
M.LSP2MPI = LSP2MPI
M.inTable = inTable
M.sqrPadding = sqrPadding
M.cropPadIm = cropPadIm

return M