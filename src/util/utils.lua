---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Shuangjun Liu.
--- DateTime: 4/23/2018 9:20 PM
---
require 'image'
require 'math'
cv = require 'cv'
require 'cv.imgproc'

local M = {}    -- package
local function TableConcat(t1,t2)
    for i=1,#t2 do
        t1[#t1+1] = t2[i]
    end
    return t1
end
local function GenVecFromTo(x1,x2)
    -- return a vector tensor from x1 to x2
    local j = x1-1
    local ts = torch.Tensor(x2-x1+1)
    ts:apply(function() j=j+1
        return j
    end)
    return ts
end
local function BoundNum(x, min, max)
    return math.min(math.max(x,min),max)
end


local function DrawLabel(Im, jts_cur, ifTxt)
    local ifDbg = 1
    ifTxt = ifTxt or false
    local I_dr=Im
    local margin = 3
    local marginTxt = 10
    --local c,h,w =

    print('jts_cur size is', jts_cur:size())
    print('im size is', Im:size())
    for i = 1, jts_cur:size(1) do
        local dr_x_ul = BoundNum(jts_cur[i][1] -margin,0,Im:size(3))
        local dr_y_ul = BoundNum(jts_cur[i][2] - margin ,0,Im:size(2))
        local dr_x_br = BoundNum(jts_cur[i][1] + margin,0,Im:size(3))
        local dr_y_br = BoundNum(jts_cur[i][2] + margin ,0,Im:size(2))
        local dr_x_txt = BoundNum(jts_cur[i][1] ,marginTxt,Im:size(3)-marginTxt)
        local dr_y_txt = BoundNum(jts_cur[i][2]  ,marginTxt,Im:size(2)-marginTxt)
         I_dr = image.drawRect(I_dr, dr_x_ul,dr_y_ul, dr_x_br, dr_y_br)
        if ifTxt then
            --print(string.format('draw text %s at location (%d, %d)',tostring(i),jts_cur[i][1],jts_cur[i][2]))
            I_dr = image.drawText(I_dr,tostring(i),dr_x_txt,dr_y_txt,{color={0,255,0}, size=1})

            --I_dr=image.drawText(I_dr, "hello\nworld", 100, 100)
        end
    end
    image.display(I_dr)
end
function M.AddNoise(augNoise)
  return function(input)
     -- AWGN:
     -- torch.randn makes noise with mean 0 and variance 1 (=stddev 1)
     --  so we multiply the tensor with our augNoise factor, that has a linear relation with
     --  the standard deviation (but the variance will be increased quadratically).
     return torch.add(input, torch.randn(input:size()):float()*augNoise)
  end
end
local function ts2cvImg(img)
    local img_cv
    if img:size(1) == 3 then -- if rgb
        img_cv = img:index(1, torch.LongTensor{3,2,1}):clone()
    end
    --print('image cv size', img_cv:size())
    img_cv = img_cv:permute(2,3,1)  -- channel back
    -- stg 1  just double back
    --img_cv = img_cv:double()
    --stg 2 multi 255 and change to byte
    img_cv = img_cv*255
    img_cv = img_cv:byte()
    return img_cv
end

-- opencv TO TS img
local function cv2tsImg(img)
    local imgTs = img:permute(3, 1, 2):float():clone()/255; -- 312 to c ,h , w from 240 320 3 -- h,w,c tim -> ts
    if imgTs:size(1) ==3 then -- if rgb
        imgTs = imgTs:index(1, torch.LongTensor{3, 2, 1}) -- r,g,b channel
    end
    return imgTs
end

local function cannyTs(img)
    local imgCv =  ts2cvImg(img)
    local imgCanny = cv.Canny{image=imgCv, threshold1=opt.cannyTh1, threshold2 = 30}
    local imTs = cv2tsImg((imgCanny))
    return imTs
end

local function lapTs(img)
    -- apply laplacian edge detection on the image
    local imgCv = ts2cvImg(img)
    local imgLap = cv.Laplacian{imgCv,ddepth = cv.CV_16S}
    local imTs = cv2tsImg(imgLap)
    return imTs
end

local function LSP2MPI(joints_gt_lsp, marginScale, n_joints)
    n_joints = n_joints or 16       -- default 16
    marginScale = marginScale or 1.2
    -- from the joints_gt_lsp format, make mpii joints_gt,
    -- also return visibles, centers, scales, and lenTorsos ( length of torso)
    -- n_joints default 16 for MPI format
    -- DB---------
    --print('joints_gt type', joints_gt_lsp:type())
    --print('marginScale is', marginScale)
    --print('n_joints type is', n_joints)
    local joints_gt_tmp = joints_gt_lsp:permute(3,2,1)  -- 3 x 14 x N
    local visiblesTmp = 1  - joints_gt_tmp:select(3,3)  -- 3rd dim the 3rd slice
    joints_gt_tmp = joints_gt_tmp:narrow(3,1,2)     -- 3rd dim  first 2
    local lenTorsosTmp = (joints_gt_tmp[{ {}, 3, {}}] - joints_gt_tmp[{ {}, 10, {}}]):norm(2, 2) -- right hip minus the left up shoulder  Nx1 norm of torso
        -- initalize joint_MPi_tmp
    local joints_MPI_tmp = torch.zeros(joints_gt_tmp:size(1), n_joints,2)
    local visiblesMPI = torch.ones(visiblesTmp:size(1), n_joints) -- N x16
    --joints_gt_tmp:add(1)      -- add or not not important here
    joints_MPI_tmp[{{},{1,6},{}}]:copy(joints_gt_tmp[{{},{1,6},{}}])
    joints_MPI_tmp[{{},{11,16},{}}]:copy(joints_gt_tmp[{{},{7,12},{}}])
    joints_MPI_tmp[{{},{7},{}}]:copy(joints_gt_tmp[{{},{3,4},{}}]:mean(2))
    joints_MPI_tmp[{{},{8},{}}]:copy(joints_gt_tmp[{{},13,{}}])
    joints_MPI_tmp[{{},{9},{}}]:copy(joints_gt_tmp[{{},13,{}}] +(joints_gt_tmp[{{},14,{}}] - joints_gt_tmp[{{},13,{}}])/3)
    joints_MPI_tmp[{{},{10},{}}]:copy(joints_gt_tmp[{{},14,{}}])

    visiblesMPI[{ {}, { 1, 6}}]:copy(visiblesTmp[{ {}, { 1, 6}}])
    visiblesMPI[{ {}, { 11, 16}}]:copy(visiblesTmp[{ {}, { 7, 12}}])
    visiblesMPI[{ {}, 8}]:copy(visiblesTmp[{ {}, 13}])
    visiblesMPI[{ {}, 10}]:copy(visiblesTmp[{ {}, 14}])

    local cTmp = torch.Tensor(joints_gt_tmp:size(1),2)
    local sTmp = torch.Tensor(joints_gt_tmp:size(1))
    for j = 1, joints_gt_tmp:size(1) do
        local joints_cur = joints_gt_tmp[j]   -- 16 x 2
        cTmp[j] = (joints_cur:max(1) + joints_cur:min(1))/2 -- average value of mean and max
        local ht = (joints_cur:max(1) - joints_cur:min(1)):max()
        sTmp[j] = ht/200 * marginScale     -- increase joint based scale
    end
    --print('things working')
    return joints_MPI_tmp, visiblesMPI, cTmp, sTmp, lenTorsosTmp
end

local function inTable(item, tbl)
    for key, value in pairs(tbl) do
        if value == item then return key end
    end
    return false
end

M.TableConcat = TableConcat
M.GenVecFromTo = GenVecFromTo
M.DrawLabel = DrawLabel
M.ts2cvImg  = ts2cvImg
M.cv2tsImg = cv2tsImg
M.cannyTs = cannyTs
M.lapTs = lapTs
M.LSP2MPI = LSP2MPI
M.inTable = inTable

return M