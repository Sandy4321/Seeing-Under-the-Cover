---
--- Generated by EmmyLua(https://github.com/EmmyLua) from git
--- Test the file configuration
--- Created by Shuangjun Liu.
--- DateTime: 4/18/2018 9:15 PM
---
require 'torch'
require 'xlua'
require 'optim'
require 'nn'
require 'nnx'
require 'nngraph'
require 'hdf5'
require 'string'
require 'image'
ffi = require 'ffi'
cv = require 'cv'   -- instead of cv2
require 'cv.videoio'
require 'cv.imgproc'
require 'cv.highgui'
require 'cv.imgcodecs'
matio = require 'matio'
local dir = require 'pl.dir'


torch.setdefaulttensortype('torch.FloatTensor')

-- Project directory
projectDir = paths.concat(os.getenv('HOME'),'pose-hg-train')

-- Process command line arguments, load helper functions
--paths.dofile('opts.lua')
paths.dofile('ref.lua')
paths.dofile('util/img.lua')    -- crop transform
paths.dofile('util/eval.lua')   -- draw pck  performance
local utils = paths.dofile('util/utils.lua')

--dsIntfPth = projectDir .. '/src/util/dataset/' .. opt.dataset .. '.lua' -- interface part
--dsIntfPth = projectDir .. '/src/util/dataset/' .. 'MPI' .. '.lua'   -- this one works
--print(dsIntfPth)
--print(paths.filep(dsIntfPth))
--local Dataset = paths.dofile(dsIntfPth)         -- why nil value
-- all called in ref
--function TableConcat(t1,t2)
--    for i=1,#t2 do
--        t1[#t1+1] = t2[i]
--    end
--    return t1
--end
paths.dofile('util/pose.lua')   -- all global in there
local Dataloader = paths.dofile('util/dataloader.lua')
loader = Dataloader.create(opt, dataset, ref)  -- loader[set] { valid, train, test}
paths.dofile('model.lua')
--fd = io.open('temp.txt', 'w')
---- model check --------
--print(model.modules)
--local mdLast = model.modules[269]
--print(model.modules[269])
--print(mdLast.train)
--mdLast:evaluate()
--print(mdLast.train)
--mdLast:training()
--print(mdLast.train)
--if opt.ftNm then
--    print('sth in ftNm')
--else
--    print('ftNm is nil')
--end
--graph.dot(model.fg, 'hg', 'myHg')
-- io test **************
--pth = '/home/jun/datasets/SYN_RR2017-11-04-13-04_800_10/joints_gt.mat'
--joints_gt = matio.load(pth,'joints_gt') -- last
--joints_gt = joints_gt:narrow(1,1,2) -- only keep 2  , narrow nothing happened
--print(joints_gt:index(3,torch.LongTensor{1}))
---------------------------------- basic**************************
-- code format test
--local ts1 = torch.Tensor({1,2})
--local ts2 = torch.Tensor({3,4})
--local ts3 = torch.Tensor{5,6}
--local tsCb
--tsCb=
--ts1
----:cat(ts2)
--:cat(ts3)
--print('tsCb is',tsCb)
--local str1 = 'mama/haha.jpg'
--print(paths.basename(str1,'.jpg'))  -- dot or not dot all works


-- declare function with parameters declared later
--function test_laterVar()
-- function can use global declared later, function is a assignment, maybe only symbols then later, y is given, call function is OK
--    x = 100
--    print(x+y)
--end
--y=50
--test_laterVar()
--tbl1 = {'new', 'bad'}
--tbl2 = {'haha', 'what',1}
--print(TableConcat(tbl1, tbl2))  -- worked
--ts1 = torch.ones(3)
--ts1 = torch.Tensor()
--ts2 = torch.zeros(2)
--print(ts1:cat(ts2)) -- succeed
--local idxsTest = torch.Tensor()
--local tmpIdxs = torch.Tensor(opt.testRt * 100)
--j=0
--tmpIdxs:apply(function()
--    j = j+1
--    return j        -- this one is going to be the value
--end)
--print(idxsTest:cat(tmpIdxs))
--ts1 = torch.zeros(2,3,4)
--ts2 = torch.ones(2,2)
--ts1[{{},{1,2},1}]:copy(ts2)     -- can ignore the rest dimension
--print(ts1)
-- tensor test
--ts1 = torch.zeros(10,4,2)
--ts2 = torch.zeros(5,4,2)
--print(ts1:cat(ts2,1))
--if false then -- false not get in
--    print('get in with false')
--else
--    print('false not get in')
--end
--
--local ts1 = torch.Tensor(0)
--local j = 0
--ts1:apply(function() j =j+1
--return j
--end)
--print(ts1)
--print('size of ts1 is', ts1:nDimension()) -- torch.longStorage of size 0
--print('the numel inside is', ts1:numel())
--if ts1:nDimension() ~=0  then   -- test empty of a tensor
--    print('no empty ts1')
--else
--    print('empty ts1')
--end
--print('torch randperm(0) is', torch.randperm(0))
--print('1st dim of ts1 is', ts1:index(1,torch.Tensor({0}):long()))   -- dimension not correct
--print('narrow operation on ts1', ts1:narrow(1,0))
--if false and (true or true) then    -- and comes earlier
--    print('passed ')
--else
--    print('not passed')
--end


-- project codes***************************
--paths.dofile('opts.lua')
--if not dataset then
--    print('there is no dataset')
--end
--print(opt.expID)        -- see if expID auto named
--print(opt.dataset)
-- get image and draw on it
--local idxImg = 20
--print('dataset train size', dataset:size('train'))
------ image IO test
local I = dataset:loadImage(10)
print(I:size())
local I_rpt = torch.repeatTensor(I,3,1,1)
print(I_rpt:size())
--print('the loaded image size is', rgb:size())
--image.display(rgb)
--local rgb_rt = image.rotate(rgb, 30* math.pi/180 )
--image.display(rgb_rt)

--local pts, c, s = dataset:getPartInfo(idxImg)
--utils.DrawLabel(rgb,pts,true)
-- test datset -----
--local sizes = dataset:size('train')
--print('train size', sizes)
--print('first few visibilities are', dataset.visibles:narrow(1,1,2))
--local ts1 = torch.Tensor(10,16)
--local ts2 = torch.zeros(2,2)
--ts1:sub(1,3):copy(dataset.visibles:index(1,torch.LongTensor{3,2,5}))
--ts1 = ts2
--print('copied ts1 is', ts1)
--print('the real first 5 is', dataset.visibles:sub(1,5))
--print('test size is', dataset:size('test'))
--ts1[1][1] = 5
--print(ts2)  -- has been changed
--print('1,1 index yields', sizes[1][1])
--dataset = Dataset()
-- check the smallest x and the file name
--local jts_x =  dataset.annot['part']:narrow(3,1,1) -- only x
--local jts_x_min = jts_x:min(2)
--print(dataset.annot['part']:size())
--local mins, indices = torch.min(jts_x_min,1)
--print('min along x', mins, indices)
--print('ind is', indices:view(1)[1] )
---- get file names  ----
--print('file imgname is', ffi.string(dataset.annot['imgname']:char()[indices:view(1)[1]]:data()))
-- check the size of  annot.part
--print('the part size is ', dataset.annot.visible:size())
--print('first 20 visible is\n', dataset.annot.visible:narrow(1,1,20))
--print('corresponding image names are')
--for idx = 1, 20 do
--    print( ffi.string(dataset.annot.imgname[idx]:char():data()))
--
--end
-- draw center of image
--local idxIm = 20
----local margin = 10
--I = dataset:loadImage(idxIm)
--local pts, c,s  =dataset:getPartInfo(idxIm)
--local lenTorso = dataset:normalize(idxIm)
--print('pts are',pts)
--print('torso length is', lenTorso)
--utils.DrawLabel(I,pts,true)
-- draw image my self
--local I_dr = image.drawText(I, 'hello, you big rubish head haning around here  is a terrible', 300,477)
--image.display(I_dr)
--local ch,h,w =I:size()    -- return tensor
--print(ch,h,w)
--local inp, out = generateSample('train', 10)    -- one sample
--print('size of the input is', inp:size())
--image.display(inp)
--I = dataset:loadImage(opt.idxRef.test[10])
--image.display(inp)
--local I = dataset:loadImage(10)
--image.display(I) -- display 10th image
--print('first 5 numbers of the read image are ', inp:sub(1,1,1,5,1,5)) -- image range from 0 to 1

--local jts_cur = dataset.joints_gt[10]
--print('the joints_gt are', dataset.joints_gt[10])
--print('the center is', dataset.centers[10])
--local I_dr = inp    -- a copy
--local margin  = 3
--local jts_cur = getPreds(out:view(1, unpack(out:size():totable())))
--jts_cur = jts_cur[1]
--jts_cur:mul(4)
----tmpLabel = tmpLabel:view(1,unpack(tmpLabel:size():totable()))
--for i = 1, jts_cur:size(1) do
--    I_dr = image.drawRect(I_dr, jts_cur[i][1]-margin, jts_cur[i][2]-margin, jts_cur[i][1]+margin, jts_cur[i][2]+margin)
--end
--image.display(I_dr)

--print('first 10 imPath is', unpack(dataset.imgPths,1,10))
--print('1000 to 1010 is', unpack(dataset.imgPths,1000,1010))


--print(int(0.01))
--I = dataset:loadImage(idxI)
----image.display(I)
--print('Image shape is', I:size())
--pts, c, s = dataset:getPartInfo(idxI)
--print('parts is', pts)
--rngX = pts:index(2,torch.LongTensor{1}):max() - pts:index(2,torch.LongTensor{1}):min()
--rngY = pts:index(2,torch.LongTensor{2}):max() - pts:index(2,torch.LongTensor{2}):min()
--print('range x,y is', rngX, rngY)
--print('ratio x, y are', rngX/I:size()[3], rngY/I:size()[2])
--print('scale is ', s)
--print('file name is', dataset:getPath(paths.basename(idxI)))
--cv.imshow{'test image', loader.ts2cvImg(I)}
--keyIn = cv.waitKey{0}
--cv.imwrite()
--print(cv)
--print(opt.datasetList:size()) -- just table
-- test the list the png file, if there are thumb files
--tmpPths = dir.getallfiles(paths.concat(opt.datasetsDir,opt.datasetList[1]),'*.png')
--print(tmpPths)

-- design the pths reader
--local imgPths = {}
--local tmpPths = {}
--local idxBase = 0
--local idxSt
--local idxsTest = torch.Tensor()
--local idxsTrain = torch.Tensor()
--local tmpIdxs = torch.Tensor()
--local dtSizes = {}
--for i,v in ipairs(opt.datasetList) do
--    print('current dir is', paths.concat(opt.datasetsDir,v) )
--    tmpPths = dir.getallfiles(paths.concat(opt.datasetsDir,v),'*.png')
--    imgPths = TableConcat(imgPths, tmpPths)
--    -- get idx for train then combine, idxSt , size
--    tmpIdxs = torch.Tensor(opt.trainRt *  #tmpPths)
--    j = idxBase
--    tmpIdxs:apply(function()
--        j = j+1
--        return j        -- this one is going to be the value
--    end)
--    print('tmpIdxs is', tmpIdxs)
--    idxsTrain:cat(tmpIdxs)
--    -- for test
--    tmpIdxs = torch.Tensor(opt.testRt * #tmpPths)
--    tmpIdxs:apply(function()
--        j = j+1
--        return j        -- this one is going to be the value
--    end)
--    idxsTest:cat(tmpIdxs)
--    dtSizes[i]= # tmpPths
--    idxBase = idxBase + # tmpPths
--end
----print(imgPths)
--print('idxs test is', idxsTest)
--print('idxs train is', idxsTrain)
--fd:close()

-------------------------------
-- raw dataset check
--local matPth ='/home/jun/datasets/SYN/SYN_RR_sarah_180423_1317_G20180508_2250_P2000_A00/'
--local joints_gt_tmp = matio.load(paths.concat(curDir,'joints_gt.mat'),'joints_gt')
--print(joints_gt_tmp:sub(1,2))

